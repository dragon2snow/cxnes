Input Bindings
--------------
Input bindings are stored as standard key-value pairs in the
configuration and have the following format:

binding [MODIFIERS] Event Name = ACTION_NAME

'Event Name' is the native input event (e.g., a keypress, button
click, etc.).  All event names are case-insensitive, so 'Keyboard F'
is the same as 'KEYBOARD F' and 'keyboard f'.

'ACTION_NAME' is the emulator action the input event is bound to.
These are also case-insensitive, so 'KEYBOARD_f' is the same as
'keyboard_f' and 'KEYBOARD_F'.

The '[MODIFIERS]' string is the list of modifiers that must be pressed
during the input event in order for the emulator action to be triggered.
This token may be omitted entirely if no modifiers are required for the
binding to trigger the named action.

If a single modifier must be pressed as part of this binding, for example
the 'CTRL' modifier, the token would look like this:

[CTRL]

If multiple modifers must be pressed at the same time, for example CTRL and ALT,
the list should specify all required modifiers in any order, separated by '-'
characters.  For example:

[CTRL-ALT]

Valid modifier names are as follows:

CTRL: Ctrl key(s) on keyboard
ALT: Alt key(s) on keyboard
SHIFT: Shift key(s) on keyboard
GUI: Windows keys / Meta keys / Command key

In addition, there is also support for 4 synthetic modifiers.  All of
these can be assigned to any key or button, but one of them has special
meaning to cxNES.  The other three can be used in custom key or button
bindings.

KBD: 'Keyboard Lock' modifier; used with Famicom Keyboard emulation to
     toggle whether keyboard events will be handled with 'normal' bindings
     or Famicom Keyboard bindings.  Assigned to the 'Home' key by default.

MOD1: Custom modifier #1
MOD2: Custom modifier #2
MOD3: Custom modifier #3

Once these modifiers have been mapped, they can be used in bindings
just like the standard keyboard modifiers.

Note that all modifiers (including standard keyboard modifiers) may
also have a normal binding assigned to them in addition to serving as
modifiers.  Pressing a modifier key/button which also has a binding
assigned to it will cause both the event bound to the modifier key to
be emitted as well as the event bound to the key/button combination
that includes the modifier.  This may have unintended side effects
depending on the bindings in question and the game being played, but
can be useful for gamepads or joysticks with few buttons.
     
The KBD, MOD1, MOD2 and MOD3 modifiers (but not the standard keyboard
modifier names) may be assigned to keys or buttons by using a
configuration key/value pair as shown below (multiple assignments are
allowed for each modifier, although no two modifers may be assigned to
the same input event):

modifier Event Name = MODIFIER_NAME

where MODIFIER_NAME is one of KBD, MOD1, MOD2 or MOD3.  'Event Name'
is the same event name as used with normal keybindings.

MOD1-3 can be especially useful when used with gamepads that have few
buttons, such as an NES controller connected to a USB adapter, to
allow more fuctions to be controlled without using the keyboard.  They
may also be used to require multiple buttons be pressed for
potentially dangerous functions, such as Reset, Save State, Load
State, etc.  See the 'Example Custom Modifier Uses' section for some
examples of how this functionality might be used.

Joystick Bindings
-----------------
Joystick bindings are specified as configuration key-value pairs.  They
are not case-sensitive.

Joystick axis bindings can take two forms: the first is for mapping
analog actions, like the Arkanoid controller dial:

binding Joystick <N> Axis <A> = ACTION_NAME

Example (bind joystick 0 Axis 3 to the Arkanoid controller dial in port 2):

binding Joystick 0 Axis 3 = ARKANOID_2_DIAL

The second is for mapping digital actions (like controller D-Pad directions)
to joystick axis directions:

binding Joystick <N> Axis <A> <+|-> = ACTION_NAME

Example (bind joystick 0 Axis 0 to Controller 1 Left if negative, Right if
positive):

binding Joystick 0 Axis 0 - = CONTROLLER_1_LEFT
binding Joystick 0 Axis 0 + = CONTROLLER_1_RIGHT

Joystick button bindings only have one form:

binding Joystick <N> Button <B> = ACTION_NAME

Example (bind joystick 0 button 0 to Controller 1 A button):

binding Joystick 0 Button 0 = CONTROLLER_1_A

Joystick hats also have only one form:

binding Joystick <N> Hat <H> <Up|Down|Left|Right> = ACTION_NAME

Example (bind joystick 0 hat 0 up to Controller 1 D-Pad Up):

binding Joystick 0 Hat 0 Up = CONTROLLER_1_UP

Note that only four directions are supported; diagonal directions trigger the
action(s) for the two adjacent directions simultaneously.

SDL GameController Bindings
---------------------------
cxNES supports SDL2's GameController API, which allows mapping
supported gamepads using a standard naming for the axes and buttons.
The actual button and axis numbers used by the gamepad do not matter,
so the same configuration can be used with any supported gamepad.  If
you have a gamepad that is recognized by this API, cxNES will support
it out of the box using reasonable default mappings so that you don't
need to configure bindings for it (unless you want different bindings,
of course).

Supported gamepads are assumed to more or less resemble an XBox 360
controller: four face buttons, two shoulder buttons, two triggers, two
analog sticks (which can be pressed down as buttons), one d-pad, start
button, back button and menu button.  The gamepad may not have all of
these buttons or axes, or may have buttons with similar placement but
different names.

If your joystick is recognized by SDL's GameController API, bindings
are specified similarly to unrecognized joysticks but the format is
slightly different.  Bindings for recognized GameControllers must use
standard names for the axes and buttons, not axis or button numbers.

Valid axis names are:
* Left X
* Left Y
* Right X
* Right Y
* Left Trigger
* Right Trigger

Valid button names are:
* A
* B
* X
* Y
* Back
* Start
* Guide
* Left Shoulder
* Right Shoulder
* Left Stick
* Right Stick
* D-Pad Up
* D-Pad Down
* D-Pad Left
* D-Pad Right

Analog actions (like the Arkanoid controller dial) are bound using this
format:

binding Joystick <N> <Axis> = ACTION_NAME

Example (binding Joystick 0's Right X axis to dial of arkanoid controller
in port 2):

binding Joystick 0 Right X = ARKANOID_2_DIAL

For binding digital actions to axis directions:

binding Joystick <N> <Axis> <+|-> = ACTION_NAME

Example (bind the left stick's X axis on joystick 0 to Controller 1 Left if negative,
Right if positive):

binding Joystick 0 Left X - = CONTROLLER_1_LEFT
binding Joystick 0 Right X + = CONTROLLER_1_RIGHT

Button bindings are specified using the following format:

binding Joystick <N> <Button> = ACTION_NAME

Example (bind joystick 0's A button to Controller 1 A
button):

binding Joystick 0 A = CONTROLLER_1_A

Bindings for these take the following form in cxnes.cfg:

binding GameController <N> <Axis or Button> = ACTION_NAME

<N> is the joystick number as detected by SDL; this can vary depending on
the order when joysticks were plugged in or turned on and what OS you're
using.  0 is always the first detected joystick, 1 is the second, and so
on.

<Button> can be one of the following: A, B, X, Y, Start, Back, Menu,
Left Shoulder, Right Shoulder, Left Stick, Right Stick, D-Pad Up,
D-Pad Down, D-Pad Left, D-Pad Right.

The four face button names (A, B, X and Y) refer to the face buttons
as labelled on the XBox 360 controller.  For those more familiar with
the Super NES layout, this is similar except the placement of A and B
are swapped, and the placement of X and Y are swapped.  Keep this in
mind when defining GameController bindings.

<Axis> can be one of the following: Left X, Left Y, Right X, Right Y,
Left Trigger, Right Trigger.  Mapping to an entire axis is generally
only useful for Arkanoid controller mappings at the moment, since most
other events only expect a simple 0/1 value (for released/pressed
respectively).

You may also specify <Axis> with a '+' or '-' appended as shown below:

binding GameController 0 Left X + = CONTROLLER_1_RIGHT
binding GameController 0 Left X - = CONTROLLER_1_LEFT

This allows different actions to be triggered by axis events depending
on which direction the axis was pressed.  The above examples are from
the default set of bindings, and specify that pressing left on
GameController 0's left stick should be bound to Left on Controller
1's D-Pad, while pressing right on the stick should be bound to Right
on the D-Pad.  With '+' or '-' appended, axis events can be bound to
digital actions (like controller d-pad button presses).

For example, the following configuration settings would allow the
first GameController gamepad to be used, with the NES B button
emulated by the GameController X button, and the NES A button emulated
by the GameController A button (these correspond to the Super NES
controller's Y and B buttons respectively):

binding.CTLRAXIS-_0_leftx = event.controller1.left
binding.CTLRAXIS+_0_leftx = event.controller1.right
binding.CTLRAXIS-_0_lefty = event.controller1.up
binding.CTLRAXIS+_0_lefty = event.controller1.down
binding.CTLRBTN_0_dpleft = event.controller1.left
binding.CTLRBTN_0_dpright = event.controller1.right
binding.CTLRBTN_0_dpup = event.controller1.up
binding.CTLRBTN_0_dpdown = event.controller1.down
binding.CTLRBTN_0_back = event.controller1.select
binding.CTLRBTN_0_start = event.controller1.start
binding.CTLRBTN_0_x = event.controller1.b
binding.CTLRBTN_0_a = event.controller1.a

Incidentally, these are some of the default bindings (along with
similar ones mapping GameControllers 1, 2 and 3 to NES controllers 2,
3 and 4 respectively).  If your gamepad is supported, cxNES should
recognize it and will give it this mapping automatically.

If your gamepad is not recognized by the GameController API and you
want it to be, you can add your own mapping to
~/.cxnes/gamecontrollerdb.txt (if this file doesn't exist, you can
create it).  Any mappings found in this file will be added to the list
of supported devices.  If the device ID specified in the file is
already known, your mapping will be override the existing one.

See https://github.com/gabomdq/SDL_GameControllerDB for more information
on adding your own mappings.

Mouse Bindings
--------------
Mouse motion events are not configurable at the moment; only certain
input devices (Zapper, Arkanoid controller) can make use of them.

Mouse button events are supported however and have the format 'MOUSEBTN_<n>',
where '<n>' is the button number.  This are treated just like key events
or joystick/gamecontroller button events.

Event Names
-----------
Event names describe either emulated hardware input events, or else
emulator control events (reset, enable/disable cheats, etc).

Below is a list of valid emulator event names, sorted by category.  cxNES
supports 4 controller ports: port 1 and 2 are the same as the ports on
the front of the NES or AV Famicom; ports 3 and 4 behave differently
depending on the four-player mode selected.  If four-player mode is set
to 'None', they are disabled.  If set to 'Four Score', they act like
ports 3 and 4 on an NES Four Score or Satellite.  If set to 'Famicom',
they act like ports 3 and 4 on a Famicom four-player adapter.

cxNES also supports the expansion port, which is used for all Famicom
accessories.  The NES version of the expansion port (on the bottom of
the NES and never used commercially) supported all 5 input lines from
both ports, whereas the Famicom version only supported D1 from $4016,
and D0-D4 from $4017.  cxNES emulates the NES version.

Miscellaneous/Emulator Control
------------------------------
event.io.four_player_mode
event.emu.toggle_fullscreen
event.emu.toggle_scanline_renderer
event.emu.toggle_sprite_limit
event.emu.toggle_sprites
event.emu.toggle_bg
event.emu.toggle_mouse_grab
event.emu.exit
event.emu.device_connect_port1
event.emu.device_connect_port2
event.emu.device_connect_port3
event.emu.device_connect_port4
event.emu.device_connect_exp
event.emu.device_select_port1
event.emu.device_select_port2
event.emu.device_select_port3
event.emu.device_select_port4
event.emu.device_select_exp
event.emu.hard_reset
event.emu.soft_reset
event.emu.toggle_cheats

VS. System Control
------------------
event.misc.dip_switch_1
event.misc.dip_switch_2
event.misc.dip_switch_3
event.misc.dip_switch_4
event.misc.dip_switch_5
event.misc.dip_switch_6
event.misc.dip_switch_7
event.misc.dip_switch_8
event.vs.coin1
event.vs.coin2
event.vs.service

FDS Input Events
----------------
event.fds.disk_select
event.fds.disk_eject

Controller (NES Controller Port 1)
----------------------------------
event.controller1.up
event.controller1.down
event.controller1.left
event.controller1.right
event.controller1.start
event.controller1.select
event.controller1.b
event.controller1.a
event.controller1.b_turbo_toggle
event.controller1.a_turbo_toggle
event.controller1.b_turbo
event.controller1.a_turbo

Controller (NES Controller Port 2)
----------------------------------
event.controller2.up
event.controller2.down
event.controller2.left
event.controller2.right
event.controller2.start
event.controller2.select
event.controller2.b
event.controller2.a
event.controller2.b_turbo_toggle
event.controller2.a_turbo_toggle
event.controller2.b_turbo
event.controller2.a_turbo
event.controller2.up
event.controller2.down
event.controller2.left
event.controller2.right

Controller (NES Controller Port 3)
----------------------------------
event.controller3.up
event.controller3.down
event.controller3.left
event.controller3.right
event.controller3.start
event.controller3.select
event.controller3.b
event.controller3.a
event.controller3.b_turbo_toggle
event.controller3.a_turbo_toggle
event.controller3.b_turbo
event.controller3.a_turbo
event.controller3.up
event.controller3.down
event.controller3.left
event.controller3.right

Controller (NES Controller Port 4)
----------------------------------
event.controller4.up
event.controller4.down
event.controller4.left
event.controller4.right
event.controller4.start
event.controller4.select
event.controller4.b
event.controller4.a
event.controller4.b_turbo_toggle
event.controller4.a_turbo_toggle
event.controller4.b_turbo
event.controller4.a_turbo
event.controller4.up
event.controller4.down
event.controller4.left
event.controller4.right

Power Pad (NES Controller Port 1)
---------------------------------
event.mat1.1
event.mat1.2
event.mat1.3
event.mat1.4
event.mat1.5
event.mat1.6
event.mat1.7
event.mat1.8
event.mat1.9
event.mat1.10
event.mat1.11
event.mat1.12

Power Pad (NES Controller Port 2)/Family Trainer (Expansion Port)
-----------------------------------------------------------------
event.mat2.1
event.mat2.2
event.mat2.3
event.mat2.4
event.mat2.5
event.mat2.6
event.mat2.7
event.mat2.8
event.mat2.9
event.mat2.10
event.mat2.11
event.mat2.12

Zapper (NES Controller Port 1)
------------------------------
event.zapper1.trigger
event.zapper1.trigger_offscreen

Zapper (NES Controller Port 2)
------------------------------
event.zapper2.trigger
event.zapper2.trigger_offscreen

Keyboard Input Events
---------------------
event.keyboard.f1
event.keyboard.f2
event.keyboard.f3
event.keyboard.f4
event.keyboard.f5
event.keyboard.f6
event.keyboard.f7
event.keyboard.f8
event.keyboard.1
event.keyboard.2
event.keyboard.3
event.keyboard.4
event.keyboard.5
event.keyboard.6
event.keyboard.7
event.keyboard.8
event.keyboard.9
event.keyboard.0
event.keyboard.minus
event.keyboard.yen
event.keyboard.stop
event.keyboard.esc
event.keyboard.q
event.keyboard.w
event.keyboard.e
event.keyboard.r
event.keyboard.t
event.keyboard.y
event.keyboard.u
event.keyboard.i
event.keyboard.o
event.keyboard.p
event.keyboard.at
event.keyboard.leftbracket
event.keyboard.enter
event.keyboard.ctrl
event.keyboard.a
event.keyboard.s
event.keyboard.d
event.keyboard.f
event.keyboard.g
event.keyboard.h
event.keyboard.j
event.keyboard.k
event.keyboard.l
event.keyboard.semicolon
event.keyboard.colon
event.keyboard.rightbracket
event.keyboard.kana
event.keyboard.lshift
event.keyboard.z
event.keyboard.x
event.keyboard.c
event.keyboard.v
event.keyboard.b
event.keyboard.n
event.keyboard.m
event.keyboard.comma
event.keyboard.period
event.keyboard.slash
event.keyboard.underscore
event.keyboard.rshift
event.keyboard.graph
event.keyboard.space
event.keyboard.clr
event.keyboard.ins
event.keyboard.del
event.keyboard.up
event.keyboard.down
event.keyboard.left
event.keyboard.right

Arkanoid Controller (NES Controller Port 1)
-------------------------------------------
event.arkanoid1.dial
event.arkanoid1.button

Arkanoid Controller (NES Controller Port 2/Expansion Port)
----------------------------------------------------------
event.arkanoid2.dial
event.arkanoid2.button

Arkanoid Controller (Second Paddle) (Expansion Port)
----------------------------------------------------
event.arkanoid1.dial
event.arkanoid1.button

Super NES Mouse (NES Controller Port 1)
---------------------------------------
event.mouse1.leftbutton
event.mouse1.rightbutton

Super NES Mouse (NES Controller Port 2)
---------------------------------------
event.mouse2.leftbutton
event.mouse2.rightbutton

Super NES Mouse (NES Controller Port 3)
---------------------------------------
event.mouse3.leftbutton
event.mouse3.rightbutton

Super NES Mouse (NES Controller Port 4)
---------------------------------------
event.mouse4.leftbutton
event.mouse4.rightbutton

Valid Key Events
----------------
Below is a list of valid key event names.

KEY_RETURN
KEY_ESCAPE
KEY_BACKSPACE
KEY_TAB
KEY_SPACE
KEY_EXCLAIM
KEY_QUOTEDBL
KEY_HASH
KEY_PERCENT
KEY_DOLLAR
KEY_AMPERSAND
KEY_QUOTE
KEY_LEFTPAREN
KEY_RIGHTPAREN
KEY_ASTERISK
KEY_PLUS
KEY_COMMA
KEY_MINUS
KEY_PERIOD
KEY_SLASH
KEY_0
KEY_1
KEY_2
KEY_3
KEY_4
KEY_5
KEY_6
KEY_7
KEY_8
KEY_9
KEY_COLON
KEY_SEMICOLON
KEY_LESS
KEY_EQUALS
KEY_GREATER
KEY_QUESTION
KEY_AT
KEY_LEFTBRACKET
KEY_BACKSLASH
KEY_RIGHTBRACKET
KEY_CARET
KEY_UNDERSCORE
KEY_BACKQUOTE
KEY_a
KEY_b
KEY_c
KEY_d
KEY_e
KEY_f
KEY_g
KEY_h
KEY_i
KEY_j
KEY_k
KEY_l
KEY_m
KEY_n
KEY_o
KEY_p
KEY_q
KEY_r
KEY_s
KEY_t
KEY_u
KEY_v
KEY_w
KEY_x
KEY_y
KEY_z
KEY_CAPSLOCK
KEY_F1
KEY_F2
KEY_F3
KEY_F4
KEY_F5
KEY_F6
KEY_F7
KEY_F8
KEY_F9
KEY_F10
KEY_F11
KEY_F12
KEY_PRINTSCREEN
KEY_SCROLLLOCK
KEY_PAUSE
KEY_INSERT
KEY_HOME
KEY_PAGEUP
KEY_DELETE
KEY_END
KEY_PAGEDOWN
KEY_RIGHT
KEY_LEFT
KEY_DOWN
KEY_UP
KEY_NUMLOCKCLEAR
KEY_KP_DIVIDE
KEY_KP_MULTIPLY
KEY_KP_MINUS
KEY_KP_PLUS
KEY_KP_ENTER
KEY_KP_1
KEY_KP_2
KEY_KP_3
KEY_KP_4
KEY_KP_5
KEY_KP_6
KEY_KP_7
KEY_KP_8
KEY_KP_9
KEY_KP_0
KEY_KP_PERIOD
KEY_APPLICATION
KEY_POWER
KEY_KP_EQUALS
KEY_F13
KEY_F14
KEY_F15
KEY_F16
KEY_F17
KEY_F18
KEY_F19
KEY_F20
KEY_F21
KEY_F22
KEY_F23
KEY_F24
KEY_EXECUTE
KEY_HELP
KEY_MENU
KEY_SELECT
KEY_STOP
KEY_AGAIN
KEY_UNDO
KEY_CUT
KEY_COPY
KEY_PASTE
KEY_FIND
KEY_MUTE
KEY_VOLUMEUP
KEY_VOLUMEDOWN
KEY_KP_COMMA
KEY_KP_EQUALSAS400
KEY_ALTERASE
KEY_SYSREQ
KEY_CANCEL
KEY_CLEAR
KEY_PRIOR
KEY_RETURN2
KEY_SEPARATOR
KEY_OUT
KEY_OPER
KEY_CLEARAGAIN
KEY_CRSEL
KEY_EXSEL
KEY_KP_00
KEY_KP_000
KEY_THOUSANDSSEPARATOR
KEY_DECIMALSEPARATOR
KEY_CURRENCYUNIT
KEY_CURRENCYSUBUNIT
KEY_KP_LEFTPAREN
KEY_KP_RIGHTPAREN
KEY_KP_LEFTBRACE
KEY_KP_RIGHTBRACE
KEY_KP_TAB
KEY_KP_BACKSPACE
KEY_KP_A
KEY_KP_B
KEY_KP_C
KEY_KP_D
KEY_KP_E
KEY_KP_F
KEY_KP_XOR
KEY_KP_POWER
KEY_KP_PERCENT
KEY_KP_LESS
KEY_KP_GREATER
KEY_KP_AMPERSAND
KEY_KP_DBLAMPERSAND
KEY_KP_VERTICALBAR
KEY_KP_DBLVERTICALBAR
KEY_KP_COLON
KEY_KP_HASH
KEY_KP_SPACE
KEY_KP_AT
KEY_KP_EXCLAM
KEY_KP_MEMSTORE
KEY_KP_MEMRECALL
KEY_KP_MEMCLEAR
KEY_KP_MEMADD
KEY_KP_MEMSUBTRACT
KEY_KP_MEMMULTIPLY
KEY_KP_MEMDIVIDE
KEY_KP_PLUSMINUS
KEY_KP_CLEAR
KEY_KP_CLEARENTRY
KEY_KP_BINARY
KEY_KP_OCTAL
KEY_KP_DECIMAL
KEY_KP_HEXADECIMAL
KEY_LCTRL
KEY_LSHIFT
KEY_LALT
KEY_LGUI
KEY_RCTRL
KEY_RSHIFT
KEY_RALT
KEY_RGUI
KEY_MODE
KEY_AUDIONEXT
KEY_AUDIOPREV
KEY_AUDIOSTOP
KEY_AUDIOPLAY
KEY_AUDIOMUTE
KEY_MEDIASELECT
KEY_WWW
KEY_MAIL
KEY_CALCULATOR
KEY_COMPUTER
KEY_AC_SEARCH
KEY_AC_HOME
KEY_AC_BACK
KEY_AC_FORWARD
KEY_AC_STOP
KEY_AC_REFRESH
KEY_AC_BOOKMARKS
KEY_BRIGHTNESSDOWN
KEY_BRIGHTNESSUP
KEY_DISPLAYSWITCH
KEY_KBDILLUMTOGGLE
KEY_KBDILLUMDOWN
KEY_KBDILLUMUP
KEY_EJECT
KEY_SLEEP

Example Custom Modifier Uses
----------------------------
To use the first SDL GameController's Back button as both a modifier and
the 'Controller 1 Select' button, put these lines in cxnes.cfg:

modifier GameController0 Back = MOD1
binding GameController0 Back = CONTROLLER_1_SELECT

You could then, for example, assign Back+X on GameController 0 to load
state 1, and Back+A to save state 1 by adding the following lines to
cxnes.cfg:

binding [MOD1] GameController0 A = SAVE_STATE_1
binding [MOD1] GameController0 X = LOAD_STATE_1

Note that with this configuration, pressing Back+X will emit both
'Controller 1 Select' and 'Load State 1' events, as modifier keys or
buttons may have a regular binding as well.

Alternatively, you might assign MOD1 to an unused button on your
gamepad, such as the 'Menu' button:

modifier GameController 0 Menu = MOD1

Pressing Menu+A will save state 1, and Menu+X will load state 1.  The
Back button will function as a select button only in this case.
Pressing the Menu button by itself will have no effect.

